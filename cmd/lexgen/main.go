package main

import (
	"encoding/json"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/bluesky-social/indigo/lex"
	"github.com/urfave/cli/v2"
)

func main() {
	app := &cli.App{
		Name:  "lexgen",
		Usage: "Generate Go types from lexicon schemas",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "config",
				Aliases: []string{"c"},
				Value:   "lexgen.json",
				Usage:   "Path to lexgen configuration file",
			},
			&cli.StringFlag{
				Name:    "lexicons",
				Aliases: []string{"l"},
				Value:   "lexicons",
				Usage:   "Path to lexicons directory",
			},
		},
		Action: func(c *cli.Context) error {
			return run(c.String("config"), c.String("lexicons"))
		},
	}

	if err := app.Run(os.Args); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run(configPath, lexiconsDir string) error {
	// Read configuration
	configData, err := os.ReadFile(configPath)
	if err != nil {
		return fmt.Errorf("failed to read config: %w", err)
	}

	var configs []lex.Package
	if err := json.Unmarshal(configData, &configs); err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	// Process each configuration
	for _, config := range configs {
		if err := processConfig(config, lexiconsDir); err != nil {
			return fmt.Errorf("failed to process config %s: %w", config.GoPackage, err)
		}
	}

	return nil
}

func processConfig(config lex.Package, lexiconsDir string) error {
	// Find all lexicon files matching the prefix
	var lexiconFiles []string
	prefixPath := filepath.Join(lexiconsDir, strings.ReplaceAll(config.Prefix, ".", "/"))

	err := filepath.WalkDir(prefixPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".json") {
			lexiconFiles = append(lexiconFiles, path)
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to walk lexicons directory: %w", err)
	}

	// Parse and generate code for each lexicon file
	var generatedFiles []GeneratedFile
	for _, file := range lexiconFiles {
		lex, err := parseLexicon(file)
		if err != nil {
			return fmt.Errorf("failed to parse lexicon %s: %w", file, err)
		}

		genFile, err := generateCode(lex, config)
		if err != nil {
			return fmt.Errorf("failed to generate code for %s: %w", file, err)
		}
		generatedFiles = append(generatedFiles, genFile)
	}

	// Write generated files
	for _, genFile := range generatedFiles {
		if err := writeGeneratedFile(genFile, config.Outdir); err != nil {
			return fmt.Errorf("failed to write generated file: %w", err)
		}
	}

	return nil
}

func parseLexicon(path string) (*lex.Schema, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var lex lex.Schema
	if err := json.Unmarshal(data, &lex); err != nil {
		return nil, err
	}

	return &lex, nil
}

type GeneratedFile struct {
	Name    string
	Package string
	Content string
}

func generateCode(lex *lex.Schema, config lex.Package) (GeneratedFile, error) {
	// Use the full ID path for the filename to avoid collisions
	// Remove the prefix to avoid redundancy, then replace dots with underscores
	name := strings.TrimPrefix(lex.ID, config.Prefix+".")
	name = strings.ReplaceAll(name, ".", "_")

	var builder strings.Builder
	builder.WriteString(fmt.Sprintf("package %s\n\n", config.GoPackage))
	builder.WriteString("// Code generated by lexgen. DO NOT EDIT.\n\n")

	// Process each definition
	for defName, defData := range lex.Defs {
		defType := defData.Type
		switch defType {
		case "query":
			code, err := generateQueryCode(lex.ID, defName, defData, lex)
			if err != nil {
				return GeneratedFile{}, err
			}
			builder.WriteString(code)

		case "procedure":
			code, err := generateProcedureCode(lex.ID, defName, defData, lex)
			if err != nil {
				return GeneratedFile{}, err
			}
			builder.WriteString(code)

		case "record":
			code, err := generateRecordCode(lex.ID, defName, defData)
			if err != nil {
				return GeneratedFile{}, err
			}
			builder.WriteString(code)

		case "object":
			// Generate nested object types
			code, err := generateObjectCode(lex.ID, defName, defData)
			if err != nil {
				return GeneratedFile{}, err
			}
			builder.WriteString(code)
		}
	}

	return GeneratedFile{
		Name:    name + ".go",
		Package: config.GoPackage,
		Content: builder.String(),
	}, nil
}

func generateQueryCode(id string, defName string, defData *lex.TypeSchema, schema *lex.Schema) (string, error) {
	var builder strings.Builder

	typeName := toTypeName(id)
	if defName != "main" {
		typeName = typeName + toFieldName(defName)
	}

	// Generate input params struct
	if defData.Parameters != nil {
		builder.WriteString(
			fmt.Sprintf("// %sParams represents the input parameters for %s\n", typeName, id),
		)
		builder.WriteString(fmt.Sprintf("type %sParams struct {\n", typeName))

		if defData.Parameters.Properties != nil {
			// Sort property names for deterministic output
			propNames := make([]string, 0, len(defData.Parameters.Properties))
			for propName := range defData.Parameters.Properties {
				propNames = append(propNames, propName)
			}
			slices.Sort(propNames)

			for _, propName := range propNames {
				propSchema := defData.Parameters.Properties[propName]
				goType := schemaToGoType(propSchema, id, schema)
				jsonTag := propName
				isRequired := slices.Contains(defData.Parameters.Required, propName)
				if !isRequired {
					jsonTag += ",omitempty"
				}

				fieldName := toFieldName(propName)
				builder.WriteString(
					fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
				)
			}
		}

		builder.WriteString("}\n\n")
	}

	// Generate output struct
	if defData.Output != nil && defData.Output.Schema != nil {
		builder.WriteString(
			fmt.Sprintf("// %sOutput represents the output for %s\n", typeName, id),
		)
		builder.WriteString(fmt.Sprintf("type %sOutput struct {\n", typeName))

		if defData.Output.Schema.Properties != nil {
			// Sort property names for deterministic output
			propNames := make([]string, 0, len(defData.Output.Schema.Properties))
			for propName := range defData.Output.Schema.Properties {
				propNames = append(propNames, propName)
			}
			slices.Sort(propNames)

			for _, propName := range propNames {
				propSchema := defData.Output.Schema.Properties[propName]
				goType := schemaToGoType(propSchema, id, schema)
				jsonTag := propName
				isRequired := slices.Contains(defData.Output.Schema.Required, propName)
				if !isRequired {
					jsonTag += ",omitempty"
				}

				fieldName := toFieldName(propName)
				builder.WriteString(
					fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
				)
			}
		}

		builder.WriteString("}\n\n")
	}

	return builder.String(), nil
}

func generateProcedureCode(id string, defName string, defData *lex.TypeSchema, schema *lex.Schema) (string, error) {
	var builder strings.Builder

	typeName := toTypeName(id)
	if defName != "main" {
		typeName = typeName + toFieldName(defName)
	}

	// Generate input struct
	if defData.Input != nil && defData.Input.Schema != nil {
		builder.WriteString(
			fmt.Sprintf("// %sInput represents the input for %s\n", typeName, id),
		)
		builder.WriteString(fmt.Sprintf("type %sInput struct {\n", typeName))

		if defData.Input.Schema.Properties != nil {
			// Sort property names for deterministic output
			propNames := make([]string, 0, len(defData.Input.Schema.Properties))
			for propName := range defData.Input.Schema.Properties {
				propNames = append(propNames, propName)
			}
			slices.Sort(propNames)

			for _, propName := range propNames {
				propSchema := defData.Input.Schema.Properties[propName]
				goType := schemaToGoType(propSchema, id, schema)
				jsonTag := propName
				isRequired := slices.Contains(defData.Input.Schema.Required, propName)
				if !isRequired {
					jsonTag += ",omitempty"
				}

				fieldName := toFieldName(propName)
				builder.WriteString(
					fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
				)
			}
		}

		builder.WriteString("}\n\n")
	}

	// Generate output struct
	if defData.Output != nil && defData.Output.Schema != nil {
		builder.WriteString(
			fmt.Sprintf("// %sOutput represents the output for %s\n", typeName, id),
		)
		builder.WriteString(fmt.Sprintf("type %sOutput struct {\n", typeName))

		if defData.Output.Schema.Properties != nil {
			// Sort property names for deterministic output
			propNames := make([]string, 0, len(defData.Output.Schema.Properties))
			for propName := range defData.Output.Schema.Properties {
				propNames = append(propNames, propName)
			}
			slices.Sort(propNames)

			for _, propName := range propNames {
				propSchema := defData.Output.Schema.Properties[propName]
				goType := schemaToGoType(propSchema, id, schema)
				jsonTag := propName
				isRequired := slices.Contains(defData.Output.Schema.Required, propName)
				if !isRequired {
					jsonTag += ",omitempty"
				}

				fieldName := toFieldName(propName)
				builder.WriteString(
					fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
				)
			}
		}

		builder.WriteString("}\n\n")
	}

	return builder.String(), nil
}

func generateRecordCode(id string, defName string, defData *lex.TypeSchema) (string, error) {
	var builder strings.Builder

	typeName := toTypeName(id)
	if defName != "main" {
		typeName = typeName + toFieldName(defName)
	}

	if defData.Record != nil {
		builder.WriteString(fmt.Sprintf("// %s represents a %s record\n", typeName, id))
		builder.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

		if defData.Record.Properties != nil {
			// Sort property names for deterministic output
			propNames := make([]string, 0, len(defData.Record.Properties))
			for propName := range defData.Record.Properties {
				propNames = append(propNames, propName)
			}
			slices.Sort(propNames)

			for _, propName := range propNames {
				propSchema := defData.Record.Properties[propName]
				goType := schemaToGoType(propSchema, id, nil)
				jsonTag := propName
				isRequired := slices.Contains(defData.Record.Required, propName)
				if !isRequired {
					jsonTag += ",omitempty"
				}

				fieldName := toFieldName(propName)
				builder.WriteString(
					fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
				)
			}
		}

		builder.WriteString("}\n\n")
	}

	return builder.String(), nil
}

func generateObjectCode(id string, defName string, defData *lex.TypeSchema) (string, error) {
	var builder strings.Builder

	typeName := toTypeName(id) + toFieldName(defName)

	builder.WriteString(fmt.Sprintf("// %s represents a %s object\n", typeName, defName))
	builder.WriteString(fmt.Sprintf("type %s struct {\n", typeName))

	if defData.Properties != nil {
		// Sort property names for deterministic output
		propNames := make([]string, 0, len(defData.Properties))
		for propName := range defData.Properties {
			propNames = append(propNames, propName)
		}
		slices.Sort(propNames)

		for _, propName := range propNames {
			propSchema := defData.Properties[propName]
			goType := schemaToGoType(propSchema, id, nil)
			jsonTag := propName
			isRequired := slices.Contains(defData.Required, propName)
			if !isRequired {
				jsonTag += ",omitempty"
			}

			fieldName := toFieldName(propName)
			builder.WriteString(
				fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag),
			)
		}
	}

	builder.WriteString("}\n\n")

	return builder.String(), nil
}

func schemaToGoType(schema *lex.TypeSchema, lexiconID string, lexSchema *lex.Schema) string {
	if schema == nil {
		return "interface{}"
	}

	switch schema.Type {
	case "string":
		return "string"
	case "integer":
		return "int64"
	case "boolean":
		return "bool"
	case "number":
		return "float64"
	case "unknown":
		return "interface{}"
	case "array":
		if schema.Items != nil {
			itemType := schemaToGoType(schema.Items, lexiconID, lexSchema)
			return "[]" + itemType
		}
		return "[]interface{}"
	case "object":
		// For nested objects, we should ideally generate a separate type
		// For now, return map or interface{}
		return "map[string]interface{}"
	case "ref":
		// Handle references - resolve to proper types
		if schema.Ref != "" {
			return resolveRef(schema.Ref, lexiconID, lexSchema)
		}
		return "interface{}"
	default:
		return "interface{}"
	}
}

func resolveRef(ref string, lexiconID string, lexSchema *lex.Schema) string {
	// Ref can be either:
	// 1. Local ref starting with # (e.g., "#record")
	// 2. External ref to another lexicon (e.g., "com.atproto.repo.strongRef")

	if strings.HasPrefix(ref, "#") {
		// Local reference - extract the def name
		defName := strings.TrimPrefix(ref, "#")
		typeName := toTypeName(lexiconID) + toFieldName(defName)
		return typeName
	}

	// External reference - convert to type name
	// For now, we'll just convert the external ref to a type name
	// In a more complete implementation, we'd need to track imported types
	return toTypeName(ref)
}

func toTypeName(id string) string {
	parts := strings.Split(id, ".")
	var result string
	for _, part := range parts {
		result += toFieldName(part)
	}
	return result
}

func toFieldName(name string) string {
	parts := strings.Split(name, "_")
	var result string
	for _, part := range parts {
		if len(part) > 0 {
			result += strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	// Handle kebab-case
	parts = strings.Split(result, "-")
	result = ""
	for _, part := range parts {
		if len(part) > 0 {
			result += strings.ToUpper(part[0:1]) + part[1:]
		}
	}
	return result
}

func writeGeneratedFile(genFile GeneratedFile, outDir string) error {
	// Ensure output directory exists
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Format the generated code
	formattedContent, err := format.Source([]byte(genFile.Content))
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	outputPath := filepath.Join(outDir, genFile.Name)
	if err := os.WriteFile(outputPath, formattedContent, 0o644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	fmt.Printf("Generated %s\n", outputPath)
	return nil
}
